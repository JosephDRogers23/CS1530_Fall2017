# CS1530 - Study Guide - Midterm 1

This covers all the material from the beginning of the class to the last lecture before the midterm.  Specifically, it will cover the following topics.

1. The SDLC - Understand what each phase is, what order they come in, what each involves
  1. Is the SDLC as pictured an accurate view of modern software development?
1. The Iron Triangle of Project Management
  1. What does it consist of?
  1. Understand/analyze trade-offs
  1. Are trade-offs always linear?
1. Understand how to calculate the number of communications pathways as the number of people increase
  1. Know Brooks' Law and be able to explain
1. Why is estimating software effort/time difficult?
1. Understand requirements vs design constraints
1. Understand functional vs non-functional requirements (quality attributes)
1. Understand implicit vs explicit requirements
1. What is the key principle of testing software?  Be able to apply it and explain if it can or cannot be applied.
1. Techniques for simplifying code/systems
  1. Decomposition
  1. Modularization
  1. Separation
  1. Incremental iterations
1. Technical vs non-technical considerations
1. Why do projects fail?
  1. Lack of user input/involvement
  1. Incomplete requirements/specifications
  1. Changing requirements/specifications
1. Failures by phase of software
  1. Most common in coding phase, but book recommends focusing on requirements phase.. why?
1. Failures by size of software
  1. Larger software -> bigger chance of failure.  Why?
1. Can anyone call themselves a Software Engineer? Why or why not?
1. Royce's Principles - focus on the ones in the slides
  1. Architecture-first approach
  1. Iterative processes
  1. Component-based development
  1. Objective quality control
  1. Demonstration-based approach
  1. Incremental releases
  1. Configurable processes
1. What is a use case?
1. What is an actor?
1. Software methodologies - what are they? which one is "best"?
1. Heavyweight vs Lightweight methodologies - understand trade-offs
1. Understand and know trade-offs of specific methodologies described in slides:
  1. Cowboy coding
  2. Waterfall
  3. Spiral
  4. Cleanroom
  5. Iterative and Incremental
  6. RAD
  7. Agile / XP
  7. Agile / Crystal
  7. Agile / Scrum
1. What is CMMI?  What are the levels of CMMI?
1. What are the main differences between traditional methodologies and Agile methodologies?
1. Understand the basic philosophy of Agile (the Agile Manifesto)
1. Understand Agile / Scrum in-depth
  1. User stories (Connextra template, how are they different from "traditional" requirements?
  1. Product backlog
  1. Sprints
  1. Story points
  1. Tasks
  1. Sprint planning
  1. Sprint review
  1. Retrospectives
  1. Standups
  1. Burndown charts
  1. Velocity
  1. Kaizen
1. What is an SRS?  What does it consist of and what does it not consist of?
1. Phases of requirements engineering
  1. Elicitation
  1. Documentation / definition
  1. Specification
  1. Prototyping
  1. Analysis
  1. Review and validation
  1. Agreement and acceptance
1. Understand high-level vs low-level (detailed) requirements elicitation
1. Categorization of requirements
  1. Clustering by dimension
  1. Clustering by use case
1. Prioritization of requirements
  1. By present or future customer demands / needs
  1. By technical prioritization (pre- and co-requisites, avoiding technical debt)
1. Analytical hierarchy process - know what it is, but you do not need to memorize the calculations
  1. Benefits / drawbacks of this approach?
1. Requirements traceability - what is it and why do we need it?
1. Types of traceability
  1. Backward-from
  2. Forward-from
  1. Backward-to
  1. Forward-to
1. What does it mean to sign off on requirements?
1. Phases of design
  1. Architectural design phase
  1. Detailed design phase
  1. What is BDUF?
  1. How are these different in Agile vs traditional ("BDUF") methodologies?
1. What is software architecture?
1. Do all systems have an architecture?
1. Can you have multiple architectures in one system?
1. Views of a software architecture
  1. Logical view
  2. Process view 
  1. Subsystem decomposition view
  1. Physical architecture view
1. Know architectural styles and when they would be useful / not useful
  1. Pipe-and-filter
  1. Event-driven
  1. Client-server
  1. Distributed
  1. Layered
  1. MVC
  1. Big ball of mud
1. Architectural tactics - what are they?
  1. Be prepared to talk about ping vs heartbeat trade-offs
1. Reference architecture - what is it?
  1. You should know what REST is but you do NOT need to know it in detail
1. Functional decomposition - what is it?
1. Complexity metrics - know what they are, general ideas, benefits/drawbacks, but you do not need to memorize calculations
  1. Halstead complexity metric
  2. McCabe's cyclomatic complexity
  3. Henry-Kafura information flow
  4. Card-Glass system complexity
1. Fan-in vs fan-out
1. Cohesion and cohesion measures
  1. Coincidental
  1. Logical
  1. Temporal
  1. Procedural
  1. Communicational
  1. Sequential
  1. Functional
1. Coupling and coupling measures
  1. Content coupling
  1. Common coupling
  1. Control coupling
  1. Stamp coupling
  1. Data coupling
1. Object-oriented design metrics
  1. Weighted methods per class
  2. Depth of inheritance tree
  3. Number of children
1. Basics of UI design - the "Golden Rules"
  1. Place the user in control
  1. Reduce the user's memory load
  1. Design consistent user interface
1. Usability evaluation
1. Project management - know the POMA activities
  1. Planning
  2. Organizing
  3. Monitoring
  4. Adjusting
1. General formula for estimation: UOE = a + b(size)^c + ACCUM(factors)
1. Know benefits/drawbacks of COCOMO (you do not need to know how to calculate)
1. Know how to do Lorenz-Kidd OO Estimation (you WILL need to know the formula for this)
1. Understand work breakdown structure
1. Understand what earned value is - you do NOT need to calculate yourself
1. Characteristics of a good implementation
  1. Readabiity
  2. Maintainability
  3. Performance
  1. Traceability
  1. Correctness
  1. Completeness
1. Programming style and guidelines
1. Defensive programming - what is it?
1. Performance optimization
  1. When to do it?
1. What is refactoring?
  1. You may refactor some code
1. Code re-use - benefits/drawbacks



